# 一次无后端的供应链系统开发实践：强约定的REST接口与后端自动化

这次的分享是今年做的一个项目的总结。

## 1. 缘起

我们在2016年初上线了一个网上药房：老白网laobai.com。半年多的时间，老白网的官网销售额在全国自营的网上药房里已经排名前5了。电商的后端需要有一套供应链管理系统，但是由于药品的特殊性，药品采购／仓储／物流等需要符合GSP规范，导致我们目前外购并同时使用两套供应链系统，一套通用版满足基本的功能需求，一套主要是药品的GSP审核的需要，两个系统之间还需要数据交换。此外，这些外购的系统也无法满足我们自己的一些定制化开发的需求。所以就迫切需要自己开发一个满足GSP规范的药品行业供应链系统。

外购的第三方的供应链系统有1000多张表，功能上的复杂度主要在数据表多且有关联，对性能／并发上到是没有太多的要求。因为可以参考第三方的数据库结构设计，也可以参考第三方的界面设计，所以数据库／前端都没有太多的不确定性。
当时这个项目的团队情况是有一个靠谱的DBA，有几个前端开发，但是缺少后端程序员。功能很多，需要开发的人力缺口很大，正是在这种情况下催生了本文提到的技术方案。方案的主要考虑是：

1. 数据库设计完成后，前端要求可以直接开始开发，不能等后端接口。
2. 后端的开发工作量要尽可能少，多用代码生成技术，因为没有专职的后端程序员。

 

## 2. REST的优点与不完备性

关于前后端之间的接口规范，主要有三种风格：RPC vs REST vs GraphQL。
RPC风格的接口规范是最传统的，但是不太合适基于Web的系统，所以本方案中不予考虑。
GraphQL调研了一下，它能够满足我们的第一个需求，前端可以定义接口，对后端接口依赖少。但是无法满足第二点，采用GraphQL的后端开发工作量很大，测试也麻烦，而且GraphQL太新，整个团队都没有使用的经验。
所以综合考虑还是采用REST规范。

按照Fielding博士的说法，REST只适用于应用软件的架构， 不包括操作系统、网络软件和一些仅仅为得到系统支持而使用网络的架构风格 (例如，进程 控制风格[53])。应用软件代表的是一个系统的“理解业务”(business-aware)的那部分功能。

REST规范在数据库类应用中使用广泛。针对数据库中的一张表，restful的api通过约定来定义好CRUD的全部接口api，不需要前后端之间沟通接口的设计，而且各种语言都有针对单表的CRUD后端自动代码生成，能够减少后端的开发工作量。约定大于配置是一个很好的软件工程实践，能够大大减少软件开发的复杂性。下面就是一个restful的api约定：


| 操作 | HTTP Method  | URI |
| :--------- | :-----| :---------- |
| 获取列表数据	|	GET	|     /表名(.:format)             |
| 添加新数据	|	POST	|    /表名(.:format)          | 
| 编辑新数据	|	GET	|     /表名/new(.:format)         |
| 编辑已有数据	|	GET	|     /表名/:id/edit(.:format)    |
| 修改已有数据	|	PUT	|     /表名/:id(.:format)         |
| 查看已有数据	|	GET	|     /表名/:id(.:format)         |
| 删除已有数据	|	DELETE	|  /表名/:id(.:format)        |


当然针对实际的软件开发需求，REST的规范还是太简单了。标准的Restful接口只有四个动作，CRUD。一个最常见的扩展（或者说是误用），就是使用更多的动作。因为常见的后端开发框架是controller+action的模式，一个controller对应一个资源，里面配置多个action对应前端用户的多个动作。典型的，比如一个帖子，点赞／取消赞是两个动作。然后随着业务的发展，还有锁帖／解锁操作，回复帖子／查看所有0回复帖子等等需要。于是就有了下面的这种url设计：

`
POST /topics/follow
POST /topics/unfollow
POST /topics/lock
POST /topics/unlock
POST /topics/reply
GET /topics/no_reply
`


慢慢的，接口越来越复杂，离原来的REST风格越来越远。当然，有人觉得这种风格也不错。而DHH的观点是这种风格url需要改造为REST的风格，比如对于点赞的场景，可以认为有一个资源是topics/follows，然后这个资源有添加和删除两个操作。
关于DHH对这种风格的讨论，可参考[这个链接](http://jeromedalbert.com/how-dhh-organizes-his-rails-controllers/)，这里是[中文翻译版](
http://mp.weixin.qq.com/s?__biz=MzAxNDEyMDI5NA==&mid=453464461&idx=1&sn=57341bf83cef600efb930a134f9ca636)。


这还只是对单表资源的CRUD操作，我们碰到的REST规范主要是缺失下面的一些部分：

1. 查询／分页／排序的支持。 REST接口只有一个列表的接口，对查询相关的功能没有约定。
2. 批量操作的支持。 REST接口默认只支持单个资源的操作，而实际的业务场景中经常需要有批量操作的需求，比如商品的批量上架、数据的批量删除等。
3. 有关联的数据表的支持。REST只支持单个资源的CRUD，而实际业务中经常有主子表的级联保存，关联表的查询等。

所以本方案主要考虑两点：

1. 扩展REST，针对上述三种场景约定好接口规范。 目的是让前端程序员只需要知道接口约定，就可以针对所有的数据库表进行接口开发。无需提供详细的接口说明文档。
2. 如何通过自动代码生成的方式实现这些规范，以减少后端开发的工作量。

还有要说明的是，本方案采用前后端分离架构，所以后端不负责提供html视图，只负责提供json的数据接口。所以下面的这些REST路由其实可以忽略：

| 操作 | HTTP Method  | URI |
| :--------- | :-----| :---------- |
| 编辑新数据	|	GET	|     /表名/new(.:format)         |
| 编辑已有数据	|	GET	|     /表名/:id/edit(.:format)    |


## 3. REST扩展：单表批量操作（添加／更新／删除）

### 批量新增接口

REST规范没有说明如何实现批量操作，也没有说明提交参数和返回值的格式。所以本方案里尽量在不改变REST的基本定义的情况下，通过对提交参数进行约定来达成目标。对于批量新增接口，我们重用REST的新增接口，只是提交的数据格式不一样。

单个新增的话，提交的是一个单个的hash对象

	{
	    "表名单数": {id:id, field:value,...}
	}
	
批量新增的话，提交的里层数据是一个数组

	{
	    "表名复数": [{id:id1, field:value,...},{id:id2}...]
	}
	
而且约定在所有的输入输出中，如果是集合对象，名字采用复数形式；如果是单个对象，名字采用单数形式。当然，还有一个约定是所有的主键的字段名都是“id”。请求中的field直接对应数据库的列名。

### 批量修改接口

对于批量修改接口，我有点左右为难。首先，无法按照批量新增的模式重用修改接口，因为REST的修改接口和单个id绑定了。如果严格参考DHH的做法，批量修改也需要抽象成一个资源，而不应该增加一个动作。但是我对这个做法很不习惯，其它动作都可以改造成CRUD，但是批量修改我认为还是和CRUD一个性质的。所以我还是决定增加了一个动作batch\_update，也是整个约定里唯一增加的动作。批量修改接口的url地址是“/表名/batch\_update.json”，提交的json数据是一个嵌套的多层hash, 内部结构以id的值为key的hash，如：

	{
	    "表名复数": {
		   id1 : { field:value1,... },
		   id2 : { field:value2,... },		   
		}
	}

### 批量删除接口
批量删除接口也没有按照DHH的说法抽象成资源，而是重用了REST的删除接口，只是id的格式不一样。批量删除接口，一次传入多个id，id之间以英文逗号“,”分割。

所以针对批量操作，本方案增加了两个约定如下：

| 操作 | HTTP Method  | URI |
| :--------- | :-----| :---------- |
| 批量修改数据	|	POST	|    /表名/batch_update(.:format)    | 
| 批量删除数据	|	DELETE	|  /表名/:id[,:id](.:format)          |


## 4. REST扩展：单表查询
单表的查询，uri直接重用rest规范，但是要约定好查询的参数的传递规范。我们定义了下面这些查询的请求格式

	s[field]=value
	s[like[field]]=value
	s[date[field]]=value
	s[range[field]]=value
	s[in[field]]=value

分别代表精确查询／like字符串模糊查询／date日期范围查询／range范围查询／in枚举查询。
如果有多个查询条件，条件之间是逻辑与的关系。

	s[field1]=value1&s[like[field2]]=value2

查询的field直接对应到数据库的字段。如果field有逗号“,”，则表示同时查询多个字段，其中一个满足条件即可，也就是OR查询。

	"/warehouses.json?s[like[company,address]]=测试"

这个查询的意思是查找所有company包含‘测试’或者address包含‘测试’的所有仓库。

针对like查询，value支持两种特殊字符“%”和“_”，其中“%”表示匹配任意多个字符，“_”匹配任意一个字符。
针对date/range/in查询，支持value中包含逗号“,”。

#### Like查询
	"/warehouses.json?s[like[fax]]=f%25"

#### 日期查询
	"/warehouses.json?s[date[created_at]]=2016-05-11"
	"/warehouses.json?s[date[created_at]]=2016-05-11,2016-05-12"

#### 数值范围查询
	"/warehouses.json?s[range[id]]=1,5"
	"/warehouses.json?s[range[id]]=,5"
	"/warehouses.json?s[range[id]]=3,"

#### 枚举In查询
	"/warehouses.json?s[in[id]]=1,2,5"

### 分页/排序

	"/warehouses.json?page=1"
	"/warehouses.json?page=1&per=100"
	"/warehouses.json?page=1&order=id+desc"


## 5. REST扩展：关联表的级联保存
## 6. REST扩展：关联表查询

存在的问题：没有对返回值进行约定。

## 7. 后端的自动代码生成
如何在给定了数据库的情况下，自动生成实现了所有上述接口约定的代码。

